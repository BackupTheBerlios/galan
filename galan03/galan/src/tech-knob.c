/* Generated by GOB (v2.0.12) on Tue Jun 26 18:44:16 2007
   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 12

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "tech-knob.h"

#include "tech-knob-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */
static const GEnumValue _tech_knob_state_values[] = {
	{ TK_STATE_IDLE, (char *)"TK_STATE_IDLE", (char *)"idle" },
	{ TK_STATE_PRESSED, (char *)"TK_STATE_PRESSED", (char *)"pressed" },
	{ TK_STATE_DRAGGING, (char *)"TK_STATE_DRAGGING", (char *)"dragging" },
	{ 0, NULL, NULL }
};

GType
tech_knob_state_get_type (void)
{
	static GType type = 0;
	if ___GOB_UNLIKELY(type == 0)
		type = g_enum_register_static ("TechKnobState", _tech_knob_state_values);
	return type;
}

/* self casting macros */
#define SELF(x) TECH_KNOB(x)
#define SELF_CONST(x) TECH_KNOB_CONST(x)
#define IS_SELF(x) TECH_IS_KNOB(x)
#define TYPE_SELF TECH_TYPE_KNOB
#define SELF_CLASS(x) TECH_KNOB_CLASS(x)

#define SELF_GET_CLASS(x) TECH_KNOB_GET_CLASS(x)

/* self typedefs */
typedef TechKnob Self;
typedef TechKnobClass SelfClass;

/* here are local prototypes */
static void ___object_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec);
static void ___object_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec);
static void tech_knob_init (TechKnob * o) G_GNUC_UNUSED;
static void tech_knob_class_init (TechKnobClass * c) G_GNUC_UNUSED;
static void tech_knob_unref_anim_list (GList * list) G_GNUC_UNUSED;
static GList * tech_knob_get_anim_list (char * name) G_GNUC_UNUSED;
static void tech_knob_check_curr_anim (TechKnob * self) G_GNUC_UNUSED;
static void ___4_tech_knob_realize (GtkWidget * widget) G_GNUC_UNUSED;
static void ___5_tech_knob_size_request (GtkWidget * widget, GtkRequisition * requisition) G_GNUC_UNUSED;
static void ___6_tech_knob_size_allocate (GtkWidget * widget, GtkAllocation * allocation) G_GNUC_UNUSED;
static gint ___7_tech_knob_expose_event (TechKnob * self, GdkEventExpose * event) G_GNUC_UNUSED;
static gint ___8_tech_knob_button_press_event (TechKnob * self, GdkEventButton * event) G_GNUC_UNUSED;
static gint ___9_tech_knob_button_release_event (TechKnob * self, GdkEventButton * event) G_GNUC_UNUSED;
static gint ___a_tech_knob_motion_notify_event (TechKnob * self, GdkEventMotion * event) G_GNUC_UNUSED;
static gint tech_knob_knob_timer (TechKnob * self) G_GNUC_UNUSED;
static void tech_knob_update_mouse_update (TechKnob * self) G_GNUC_UNUSED;
static void tech_knob_update_mouse (TechKnob * self, gint x, gint y) G_GNUC_UNUSED;
static void tech_knob_update_mouse_abs (TechKnob * self, gint x, gint y) G_GNUC_UNUSED;

enum {
	PROP_0,
	PROP_ANIM_NAME
};

/* pointer to the class of our parent */
static GtkRangeClass *parent_class = NULL;

/* Short form macros */
#define self_unref_anim_list tech_knob_unref_anim_list
#define self_get_anim_list tech_knob_get_anim_list
#define self_check_curr_anim tech_knob_check_curr_anim
#define self_knob_timer tech_knob_knob_timer
#define self_update_mouse_update tech_knob_update_mouse_update
#define self_update_mouse tech_knob_update_mouse
#define self_update_mouse_abs tech_knob_update_mouse_abs
GType
tech_knob_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (TechKnobClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) tech_knob_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (TechKnob),
			0 /* n_preallocs */,
			(GInstanceInitFunc) tech_knob_init,
			NULL
		};

		type = g_type_register_static (GTK_TYPE_RANGE, "TechKnob", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((TechKnob *)g_object_new(tech_knob_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static TechKnob * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static TechKnob *
GET_NEW_VARG (const char *first, ...)
{
	TechKnob *ret;
	va_list ap;
	va_start (ap, first);
	ret = (TechKnob *)g_object_new_valist (tech_knob_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static void
___dispose (GObject *obj_self)
{
#define __GOB_FUNCTION__ "Tech:Knob::dispose"
	TechKnob *self G_GNUC_UNUSED = TECH_KNOB (obj_self);
	if (G_OBJECT_CLASS (parent_class)->dispose) \
		(* G_OBJECT_CLASS (parent_class)->dispose) (obj_self);
#line 41 "tech-knob.gob"
	if(self->_priv->anim_list) { self_unref_anim_list ((gpointer) self->_priv->anim_list); self->_priv->anim_list = NULL; }
#line 143 "tech-knob.c"
}
#undef __GOB_FUNCTION__


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "Tech:Knob::finalize"
	TechKnob *self G_GNUC_UNUSED = TECH_KNOB (obj_self);
	gpointer priv G_GNUC_UNUSED = self->_priv;
	if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
#line 44 "tech-knob.gob"
	if(self->_priv->anim_name) { g_free ((gpointer) self->_priv->anim_name); self->_priv->anim_name = NULL; }
#line 158 "tech-knob.c"
}
#undef __GOB_FUNCTION__

static void 
tech_knob_init (TechKnob * o G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "Tech:Knob::init"
	o->_priv = G_TYPE_INSTANCE_GET_PRIVATE(o,TECH_TYPE_KNOB,TechKnobPrivate);
#line 40 "tech-knob.gob"
	o->_priv->anim_list =  NULL ;
#line 169 "tech-knob.c"
#line 43 "tech-knob.gob"
	o->_priv->anim_name =  NULL ;
#line 172 "tech-knob.c"
}
#undef __GOB_FUNCTION__
static void 
tech_knob_class_init (TechKnobClass * c G_GNUC_UNUSED)
{
#define __GOB_FUNCTION__ "Tech:Knob::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) c;
	GtkWidgetClass *gtk_widget_class = (GtkWidgetClass *)c;

	g_type_class_add_private(c,sizeof(TechKnobPrivate));
#line 28 "tech-knob.gob"
	c->pixbuf_cache =  g_hash_table_new_full( g_str_hash, g_str_equal, g_free, g_object_unref ) ;
#line 185 "tech-knob.c"

	parent_class = g_type_class_ref (GTK_TYPE_RANGE);

#line 109 "tech-knob.gob"
	gtk_widget_class->realize = ___4_tech_knob_realize;
#line 141 "tech-knob.gob"
	gtk_widget_class->size_request = ___5_tech_knob_size_request;
#line 146 "tech-knob.gob"
	gtk_widget_class->size_allocate = ___6_tech_knob_size_allocate;
#line 157 "tech-knob.gob"
	gtk_widget_class->expose_event = ___7_tech_knob_expose_event;
#line 190 "tech-knob.gob"
	gtk_widget_class->button_press_event = ___8_tech_knob_button_press_event;
#line 220 "tech-knob.gob"
	gtk_widget_class->button_release_event = ___9_tech_knob_button_release_event;
#line 267 "tech-knob.gob"
	gtk_widget_class->motion_notify_event = ___a_tech_knob_motion_notify_event;
#line 203 "tech-knob.c"
	g_object_class->dispose = ___dispose;
	g_object_class->finalize = ___finalize;
	g_object_class->get_property = ___object_get_property;
	g_object_class->set_property = ___object_set_property;
    {
	GParamSpec   *param_spec;

	param_spec = g_param_spec_string
		("anim_name" /* name */,
		 "anim_name" /* nick */,
		 "Name of the animation to use" /* blurb */,
		 "new-knob02.png" /* default_value */,
		 (GParamFlags)(G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (g_object_class,
		PROP_ANIM_NAME,
		param_spec);
    }
}
#undef __GOB_FUNCTION__

static void
___object_set_property (GObject *object,
	guint property_id,
	const GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "Tech:Knob::set_property"
{
	TechKnob *self G_GNUC_UNUSED;

	self = TECH_KNOB (object);

	switch (property_id) {
	case PROP_ANIM_NAME:
		{
#line 99 "tech-knob.gob"

	    self->_priv->anim_name = g_strdup( g_value_get_string(VAL) );
	    self_check_curr_anim( self );
	
#line 243 "tech-knob.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__

static void
___object_get_property (GObject *object,
	guint property_id,
	GValue *VAL G_GNUC_UNUSED,
	GParamSpec *pspec G_GNUC_UNUSED)
#define __GOB_FUNCTION__ "Tech:Knob::get_property"
{
	TechKnob *self G_GNUC_UNUSED;

	self = TECH_KNOB (object);

	switch (property_id) {
	case PROP_ANIM_NAME:
		{
#line 103 "tech-knob.gob"

	    g_value_set_string(VAL, self->_priv->anim_name );
	
#line 276 "tech-knob.c"
		}
		break;
	default:
/* Apparently in g++ this is needed, glib is b0rk */
#ifndef __PRETTY_FUNCTION__
#  undef G_STRLOC
#  define G_STRLOC	__FILE__ ":" G_STRINGIFY (__LINE__)
#endif
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}
#undef __GOB_FUNCTION__



#line 35 "tech-knob.gob"
static void 
tech_knob_unref_anim_list (GList * list)
#line 296 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::unref_anim_list"
{
#line 35 "tech-knob.gob"
	
	g_list_foreach( list, (GFunc) g_object_unref, NULL );
	g_list_free( list );
    }}
#line 305 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 53 "tech-knob.gob"
static GList * 
tech_knob_get_anim_list (char * name)
#line 311 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::get_anim_list"
{
#line 53 "tech-knob.gob"
	

	GError *err = NULL;
	GdkPixbuf *animation; 
	GList *retval = NULL;
	int x, w;

	animation = gdk_pixbuf_new_from_file( name, &err );
	if( animation ) {
	    w = gdk_pixbuf_get_width( animation );

	    for(x=0; x<w; x+=KNOB_SIZE ) {
		GdkPixbuf *pixbuf = gdk_pixbuf_new_subpixbuf( animation, x, 0, KNOB_SIZE, KNOB_SIZE );
		retval = g_list_append( retval, pixbuf );
	    }
	    return retval;
	} else {
	    // Create empty GdkPixBuf...
	    return NULL;
	}
    }}
#line 337 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 75 "tech-knob.gob"
static void 
tech_knob_check_curr_anim (TechKnob * self)
#line 343 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::check_curr_anim"
#line 75 "tech-knob.gob"
	g_return_if_fail (self != NULL);
#line 75 "tech-knob.gob"
	g_return_if_fail (TECH_IS_KNOB (self));
#line 350 "tech-knob.c"
{
#line 75 "tech-knob.gob"
	
	//GdkPixbuf *anim = g_hash_table_lookup( SELF_CLASS( G_OBJECT(self)->klass )->pixbuf_cache, self->_priv->anim_name );
	
	GList *anim = g_hash_table_lookup( SELF_CLASS( G_OBJECT_GET_CLASS(self) )->pixbuf_cache, self->_priv->anim_name );

	if( anim == NULL )
	    //anim = self_load_anim( self );
	    anim = self_get_anim_list( self->_priv->anim_name );

	if( anim != self->_priv->anim_list ) {
	    //g_object_unref( self->_priv->curr_anim );
	    self_unref_anim_list( self->_priv->anim_list );
	    self->_priv->anim_list = anim;
	}

	// TODO: self_expose( self );
    }}
#line 370 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 109 "tech-knob.gob"
static void 
___4_tech_knob_realize (GtkWidget * widget G_GNUC_UNUSED)
#line 376 "tech-knob.c"
#define PARENT_HANDLER(___widget) \
	{ if(GTK_WIDGET_CLASS(parent_class)->realize) \
		(* GTK_WIDGET_CLASS(parent_class)->realize)(___widget); }
{
#define __GOB_FUNCTION__ "Tech:Knob::realize"
{
#line 109 "tech-knob.gob"
	

	GdkWindowAttr attributes;
	gint attributes_mask;

	GTK_WIDGET_SET_FLAGS(widget, GTK_REALIZED);

	attributes.x = widget->allocation.x;
	attributes.y = widget->allocation.y;
	attributes.width = widget->allocation.width;
	attributes.height = widget->allocation.height;
	attributes.wclass = GDK_INPUT_OUTPUT;
	attributes.window_type = GDK_WINDOW_CHILD;
	attributes.event_mask =
	    gtk_widget_get_events (widget) | 
	    GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK | 
	    GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK |
	    GDK_POINTER_MOTION_HINT_MASK;
	attributes.visual = gtk_widget_get_visual(widget);
	attributes.colormap = gtk_widget_get_colormap(widget);

	attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
	widget->window = gdk_window_new(widget->parent->window, &attributes, attributes_mask);

	widget->style = gtk_style_attach(widget->parent->style, widget->window);

	gdk_window_set_user_data(widget->window, widget);


	gtk_style_set_background(widget->style, widget->window, GTK_STATE_NORMAL);
    }}
#line 415 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 141 "tech-knob.gob"
static void 
___5_tech_knob_size_request (GtkWidget * widget G_GNUC_UNUSED, GtkRequisition * requisition)
#line 422 "tech-knob.c"
#define PARENT_HANDLER(___widget,___requisition) \
	{ if(GTK_WIDGET_CLASS(parent_class)->size_request) \
		(* GTK_WIDGET_CLASS(parent_class)->size_request)(___widget,___requisition); }
{
#define __GOB_FUNCTION__ "Tech:Knob::size_request"
{
#line 141 "tech-knob.gob"
	
	requisition->width = KNOB_SIZE;
	requisition->height = KNOB_SIZE;
    }}
#line 434 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 146 "tech-knob.gob"
static void 
___6_tech_knob_size_allocate (GtkWidget * widget G_GNUC_UNUSED, GtkAllocation * allocation)
#line 441 "tech-knob.c"
#define PARENT_HANDLER(___widget,___allocation) \
	{ if(GTK_WIDGET_CLASS(parent_class)->size_allocate) \
		(* GTK_WIDGET_CLASS(parent_class)->size_allocate)(___widget,___allocation); }
{
#define __GOB_FUNCTION__ "Tech:Knob::size_allocate"
{
#line 146 "tech-knob.gob"
	

	widget->allocation = *allocation;

	if (GTK_WIDGET_REALIZED(widget)) {
	    gdk_window_move_resize(widget->window,
		    allocation->x, allocation->y,
		    allocation->width, allocation->height);
	}
    }}
#line 459 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 157 "tech-knob.gob"
static gint 
___7_tech_knob_expose_event (TechKnob * self G_GNUC_UNUSED, GdkEventExpose * event)
#line 466 "tech-knob.c"
#define PARENT_HANDLER(___self,___event) \
	((GTK_WIDGET_CLASS(parent_class)->expose_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->expose_event)(___self,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Tech:Knob::expose_event"
#line 157 "tech-knob.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 157 "tech-knob.gob"
	g_return_val_if_fail (TECH_IS_KNOB (self), (gint )0);
#line 477 "tech-knob.c"
{
#line 157 "tech-knob.gob"
	

	GtkWidget *widget = GTK_WIDGET( self );
	GtkRange *range = GTK_RANGE( self );
	gfloat dx, dy;

	if (event->count > 0)
	    return FALSE;

	GtkAdjustment *adj = gtk_range_get_adjustment( range );
	gdk_window_clear_area(widget->window, 0, 0, widget->allocation.width, widget->allocation.height);

	dx = adj->value - adj->lower;
	dy = adj->upper - adj->lower;
	GList *framelist = self->_priv->anim_list;

	if (dy != 0) {
	    GdkPixbuf *pixbuf;

	    dx = MIN(MAX(dx / dy, 0), 1);
	    //dx = (1-dx) * (g_list_length( framelist )-0.5) * 0.75 + 0.125 * g_list_length( framelist );
	    dx = (dx) * (g_list_length( framelist ) - 1 );

	    pixbuf = GDK_PIXBUF( g_list_nth_data( framelist, (int) dx) );

	    gdk_pixbuf_render_to_drawable_alpha( pixbuf, widget->window,
		    0, 0, 0, 0, gdk_pixbuf_get_width( pixbuf ), gdk_pixbuf_get_height( pixbuf ), GDK_PIXBUF_ALPHA_FULL, 0, 0,0,0 );
	}

	return FALSE;
    }}
#line 511 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 190 "tech-knob.gob"
static gint 
___8_tech_knob_button_press_event (TechKnob * self G_GNUC_UNUSED, GdkEventButton * event)
#line 518 "tech-knob.c"
#define PARENT_HANDLER(___self,___event) \
	((GTK_WIDGET_CLASS(parent_class)->button_press_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->button_press_event)(___self,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Tech:Knob::button_press_event"
#line 190 "tech-knob.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 190 "tech-knob.gob"
	g_return_val_if_fail (TECH_IS_KNOB (self), (gint )0);
#line 529 "tech-knob.c"
{
#line 190 "tech-knob.gob"
	

	//g_return_val_if_fail(widget != NULL, FALSE);
	//g_return_val_if_fail(GTK_IS_KNOB(self), FALSE);
	g_return_val_if_fail(event != NULL, FALSE);


	switch (self->_priv->state) {
	    case TK_STATE_IDLE:
		switch (event->button) {
		    case 1:
		    case 3:
			gtk_grab_add( GTK_WIDGET( self ));
			self->_priv->state = TK_STATE_PRESSED;
			self->_priv->saved_x = event->x;
			self->_priv->saved_y = event->y;
			break;

		    default:
			break;
		}
		break;

	    default:
		break;
	}

	return FALSE;
    }}
#line 561 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 220 "tech-knob.gob"
static gint 
___9_tech_knob_button_release_event (TechKnob * self G_GNUC_UNUSED, GdkEventButton * event)
#line 568 "tech-knob.c"
#define PARENT_HANDLER(___self,___event) \
	((GTK_WIDGET_CLASS(parent_class)->button_release_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->button_release_event)(___self,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Tech:Knob::button_release_event"
#line 220 "tech-knob.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 220 "tech-knob.gob"
	g_return_val_if_fail (TECH_IS_KNOB (self), (gint )0);
#line 579 "tech-knob.c"
{
#line 220 "tech-knob.gob"
	

	//g_return_val_if_fail(widget != NULL, FALSE);
	//g_return_val_if_fail(GTK_IS_KNOB(widget), FALSE);
	g_return_val_if_fail(event != NULL, FALSE);

	

	GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );

	switch (self->_priv->state) {
	    case TK_STATE_PRESSED:
		gtk_grab_remove( GTK_WIDGET( self ) );
		self->_priv->state = TK_STATE_IDLE;

		switch (event->button) {
		    case 1:
			adj->value -= adj->page_increment;
			gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");
			break;

		    case 3:
			adj->value += adj->page_increment;
			gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");
			break;

		    default:
			break;
		}
		break;

	    case TK_STATE_DRAGGING:
		gtk_grab_remove(GTK_WIDGET( self ));
		self->_priv->state = TK_STATE_IDLE;

		if (gtk_range_get_update_policy( GTK_RANGE( self ) ) != GTK_UPDATE_CONTINUOUS && self->_priv->old_value != adj->value)
		    gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");

		break;

	    default:
		break;
	}

	return FALSE;
    }}
#line 628 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 267 "tech-knob.gob"
static gint 
___a_tech_knob_motion_notify_event (TechKnob * self G_GNUC_UNUSED, GdkEventMotion * event)
#line 635 "tech-knob.c"
#define PARENT_HANDLER(___self,___event) \
	((GTK_WIDGET_CLASS(parent_class)->motion_notify_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->motion_notify_event)(___self,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Tech:Knob::motion_notify_event"
#line 267 "tech-knob.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 267 "tech-knob.gob"
	g_return_val_if_fail (TECH_IS_KNOB (self), (gint )0);
#line 646 "tech-knob.c"
{
#line 267 "tech-knob.gob"
	
	GdkModifierType mods;
	gint x, y;
	GtkWidget *widget = GTK_WIDGET(self);

	g_return_val_if_fail(widget != NULL, FALSE);
	//g_return_val_if_fail(GTK_IS_KNOB(widget), FALSE);
	g_return_val_if_fail(event != NULL, FALSE);

	//knob = GTK_KNOB(widget);

	x = event->x;
	y = event->y;

	if (event->is_hint || (event->window != widget->window))
	    gdk_window_get_pointer(widget->window, &x, &y, &mods);

	switch (self->_priv->state) {
	    case TK_STATE_PRESSED:
		self->_priv->state = TK_STATE_DRAGGING;
		/* fall through */

	    case TK_STATE_DRAGGING:
		if (mods & GDK_BUTTON1_MASK) {
		    self_update_mouse(self, x, y);
		    return TRUE;
		} else if (mods & GDK_BUTTON3_MASK) {
		    self_update_mouse_abs(self, x, y);
		    return TRUE;
		}
		break;

	    default:
		break;
	}

	return FALSE;
    }}
#line 687 "tech-knob.c"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 306 "tech-knob.gob"
static gint 
tech_knob_knob_timer (TechKnob * self)
#line 694 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::knob_timer"
#line 306 "tech-knob.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 306 "tech-knob.gob"
	g_return_val_if_fail (TECH_IS_KNOB (self), (gint )0);
#line 701 "tech-knob.c"
{
#line 306 "tech-knob.gob"
	
	//g_return_val_if_fail(knob != NULL, FALSE);
	//g_return_val_if_fail(GTK_IS_KNOB(knob), FALSE);

	GtkUpdateType policy = gtk_range_get_update_policy( GTK_RANGE( self ) );
	if (policy == GTK_UPDATE_DELAYED) {
	    GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );
	    gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");
	}

	return FALSE;	/* don't keep running this timer */
    }}
#line 716 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 319 "tech-knob.gob"
static void 
tech_knob_update_mouse_update (TechKnob * self)
#line 722 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::update_mouse_update"
#line 319 "tech-knob.gob"
	g_return_if_fail (self != NULL);
#line 319 "tech-knob.gob"
	g_return_if_fail (TECH_IS_KNOB (self));
#line 729 "tech-knob.c"
{
#line 319 "tech-knob.gob"
	
	GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );
	if (gtk_range_get_update_policy( GTK_RANGE( self )) == GTK_UPDATE_CONTINUOUS)
	    gtk_signal_emit_by_name(GTK_OBJECT(adj), "value_changed");
	else {
	    gtk_widget_draw(GTK_WIDGET(self), NULL);

	    if (gtk_range_get_update_policy( GTK_RANGE( self )) == GTK_UPDATE_DELAYED) {
		if (self->_priv->timer)
		    gtk_timeout_remove(self->_priv->timer);

		self->_priv->timer = gtk_timeout_add (SCROLL_DELAY_LENGTH, (GtkFunction) self_knob_timer,
			(gpointer) self);
	    }
	}
    }}
#line 748 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 336 "tech-knob.gob"
static void 
tech_knob_update_mouse (TechKnob * self, gint x, gint y)
#line 754 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::update_mouse"
#line 336 "tech-knob.gob"
	g_return_if_fail (self != NULL);
#line 336 "tech-knob.gob"
	g_return_if_fail (TECH_IS_KNOB (self));
#line 761 "tech-knob.c"
{
#line 336 "tech-knob.gob"
	
	gfloat old_value;
	gfloat dv;

	//g_return_if_fail(knob != NULL);
	//g_return_if_fail(GTK_IS_KNOB(knob));
	
	GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );

	old_value = adj->value;

	dv = (self->_priv->saved_y - y) * adj->step_increment;
	self->_priv->saved_x = x;
	self->_priv->saved_y = y;

	adj->value += dv;

	if (adj->value != old_value)
	    self_update_mouse_update(self);
    }}
#line 784 "tech-knob.c"
#undef __GOB_FUNCTION__

#line 357 "tech-knob.gob"
static void 
tech_knob_update_mouse_abs (TechKnob * self, gint x, gint y)
#line 790 "tech-knob.c"
{
#define __GOB_FUNCTION__ "Tech:Knob::update_mouse_abs"
#line 357 "tech-knob.gob"
	g_return_if_fail (self != NULL);
#line 357 "tech-knob.gob"
	g_return_if_fail (TECH_IS_KNOB (self));
#line 797 "tech-knob.c"
{
#line 357 "tech-knob.gob"
	
	gfloat old_value;
	gdouble angle;

	//g_return_if_fail(knob != NULL);
	//g_return_if_fail(GTK_IS_KNOB(knob));

	GtkAdjustment *adj = gtk_range_get_adjustment( GTK_RANGE( self ) );

	old_value = adj->value;

	x -= KNOB_SIZE>>1;
	y -= KNOB_SIZE>>1;
	y = -y;	/* inverted cartesian graphics coordinate system */

	angle = atan2(y, x) / M_PI;
	if (angle < -0.5)
	    angle += 2;

	angle = -(2.0/3.0) * (angle - 1.25);	/* map [1.25pi, -0.25pi] onto [0, 1] */
	angle *= adj->upper - adj->lower;
	angle += adj->lower;

	adj->value = angle;

	if (adj->value != old_value)
	    self_update_mouse_update(self);
    }}
#line 828 "tech-knob.c"
#undef __GOB_FUNCTION__
